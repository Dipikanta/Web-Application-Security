Q1. What is access control and why is it central to application security?
Ans:
Access control decides who can do what on which resource.
Authentication answers who you are.
Access control enforces what you’re allowed to do.

-> What’s really happening:
For every request, the system must evaluate:
	• identity (user / service)
	• action (read, write, delete)
	• resource (object, record, API)
	• context (tenant, state, business rules)
This decision must happen before the action executes.

-> Where systems fail:
	• Access checks done only at:
		○ UI
		○ API gateway
	• Backend trusts incoming identifiers blindly

Q2. What is IDOR and why is it so common?
Ans:
IDOR happens when users can access other users’ data by changing an identifier.

-> What’s really happening:
	• Client sends a resource ID (orderId, userId)
	• Backend:
		○ fetches the object
		○ does not verify ownership
	• Any authenticated user can enumerate data

-> Why it’s so common:
	• Developers check authentication
	• They forget object-level authorization
	• IDs look random, so they “feel safe”

-> Impact:
	• Data leakage
	• Account takeover paths
	• Compliance violations

Q3. Why are role-based checks alone insufficient for access control?
Ans:
Having the right role doesn’t mean you own the data.

-> What’s really happening:
	• Two users:
		○ same role
		○ different resources
	• Role check passes
	• Ownership check is missing
Real-world example
	• Both users are “customers”
	• One accesses another customer’s order

-> Correct approach:
Access = role AND object relationship

Q4. Where should access control be enforced in a system?
Ans:
Access control must be enforced close to the data.

-> What’s really happening:
	• Frontend:
		○ improves UX
		○ cannot be trusted
	• API gateway:
		○ enforces coarse rules
		○ lacks business context
	• Backend service:
		○ knows:
			- ownership
			- tenant
			- state
			- business rules

-> Correct design:
	• Backend = final authority
	• Gateway = defense in depth

Q5. How do you prevent IDOR in practice?
Ans:
Never trust client-supplied identifiers.

-> What’s really happening:
For every request:
	1. Identify the caller
	2. Fetch the resource securely
	3. Verify:
		○ ownership or
		○ explicit permission
	4. Only then perform the action

-> Good patterns:
	• Query by:
		○ resource ID + user ID
	• Centralized authorization logic
	• Deny by default

-> Bad patterns:
	• “If ID exists, return it”
	• Security through obscurity (UUIDs)

Q6. How does IDOR appear in APIs even when IDs are not exposed directly?
Ans:
Hiding IDs does not prevent IDOR.

-> What’s really happening:
	• APIs often use:
		○ indirect references
		○ encoded IDs
		○ UUIDs
	• Backend still:
		○ resolves the reference
		○ fetches the object
		○ skips ownership check

-> Why this fails:
	• Attackers don’t need to guess IDs
	• They reuse:
		○ previously seen references
		○ references from logs, emails, URLs

-> Correct mindset:
Authorization, not obscurity, prevents IDOR.

Q7. How does IDOR manifest in multi-tenant systems?
Ans:
IDOR becomes cross-tenant data leakage.

-> What’s really happening:
	• Requests include:
		○ resource ID
		○ sometimes tenant ID
	• Backend:
		○ trusts tenant ID from client
		○ does not enforce tenant scoping
Common failure
	• Querying by:
		○ resource ID only
	• Not binding:
		○ user → tenant → resource

-> Correct pattern:
Every access check must enforce:
	• tenant isolation
	• object ownership

Q8. What is indirect object reference and how is it different from IDOR?
Ans: 
Indirect references change how objects are referenced, not how access is controlled.

-> What’s really happening
	• Direct reference:
		○ /orders/123
	• Indirect reference:
		○ /orders/abcxyz
	• Backend maps:
		○ abcxyz → 123
Key mistake
	• Developers assume indirection = security
	• Authorization checks are still missing
Important truth
Indirect references do not replace access control.

Q9. How should access control be tested effectively?
Ans:
You test access control by breaking assumptions, not following happy paths.

-> What’s really happening
Effective testing includes:
	• horizontal access attempts (peer data)
	• vertical access attempts (privilege escalation)
	• cross-tenant access
What to look for
	• Missing checks
	• Inconsistent enforcement
	• Partial protections
Why automated tests miss this
	• Tools don’t understand business context
	• Human reasoning is required

Q10. How do you design access control so it scales and stays correct?
Ans:
Access control should be centralized, explicit, and default-deny.

-> What’s really happening:
Good systems:
	• define access rules clearly
	• enforce them consistently
	• avoid scattered logic
Design principles
	• One source of truth for authorization
	• Explicit permission checks
	• Fail closed, not open
Red flags
	• Copy-paste access checks
	• “We’ll add it later”
	• UI-based enforcement


Summary :
Auth ≠ Access
Roles ≠ Ownership
IDs ≠ Permission
Backend ≠ Trustless
Obscurity ≠ Security
Tenant ≠ User
Reference ≠ Permission
Testing breaks assumptions
Default deny wins


